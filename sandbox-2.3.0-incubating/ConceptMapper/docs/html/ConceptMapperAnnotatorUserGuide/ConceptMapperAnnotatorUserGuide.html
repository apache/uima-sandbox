<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Apache UIMA ConceptMapper Annotator Documentation</title><link rel="stylesheet" href="css/stylesheet-html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en" id="d0e2"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>
		Apache UIMA ConceptMapper Annotator Documentation
	</h1></div><div><div class="authorgroup"><h3 class="corpauthor">Authors: The Apache UIMA Development Community</h3></div></div><div><span class="productname">Apache UIMA Sandbox<br></span></div><div><p class="releaseinfo">Version 2.3.0</p></div><div><p class="copyright">Copyright &copy; 2008, 2009 The Apache Software Foundation</p></div><div><div class="legalnotice"><a name="d0e15"></a><p> </p><p><b>Incubation Notice and Disclaimer.&nbsp;</b>Apache UIMA is an effort undergoing incubation at the Apache Software Foundation (ASF). 
          Incubation is required of all newly accepted projects until a further review indicates that 
          the infrastructure, communications, and decision making process have stabilized in a manner 
          consistent with other successful ASF projects. While incubation status is not necessarily 
          a reflection of the completeness or stability of the code, 
          it does indicate that the project has yet to be fully endorsed by the ASF.</p><p> </p><p> </p><p><b>License and Disclaimer.&nbsp;</b>The ASF licenses this documentation
           to you under the Apache License, Version 2.0 (the
           "License"); you may not use this documentation except in compliance
           with the License.  You may obtain a copy of the License at
         
         </p><div class="blockquote"><blockquote class="blockquote"><p>
             <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">http://www.apache.org/licenses/LICENSE-2.0</a>
           </p></blockquote></div><p>
         
           Unless required by applicable law or agreed to in writing,
           this documentation and its contents are distributed under the License 
           on an 
           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
           KIND, either express or implied.  See the License for the
           specific language governing permissions and limitations
           under the License.
         </p><p> </p><p> </p><p><b>Trademarks.&nbsp;</b>All terms mentioned in the text that are known to be trademarks or 
        service marks have been appropriately capitalized.  Use of such terms
        in this book should not be regarded as affecting the validity of the
        the trademark or service mark.
        </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#intro">Introduction</a></span></dt><dt><span class="chapter"><a href="#usingcm">1. Using ConceptMapper</a></span></dt><dt><span class="chapter"><a href="#config">2. Functionality</a></span></dt><dd><dl><dt><span class="section"><a href="#dict">2.1. Dictionaries</a></span></dt><dt><span class="section"><a href="#tokenizer">2.2. Dictionary Entry Tokenization</a></span></dt><dt><span class="section"><a href="#paramInput">2.3. Input Document Processing</a></span></dt><dt><span class="section"><a href="#paramLookup">2.4. Lookup Strategies</a></span></dt><dt><span class="section"><a href="#paramOutput">2.5. Output Options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configParams">3. Configuration Parameters</a></span></dt></dl></div><div class="preface" lang="en" id="intro"><div class="titlepage"><div><div><h2 class="title"><a name="intro"></a>Introduction</h2></div></div></div><p>
			ConceptMapper is a highly configurable, high performance dictionary lookup tool, implemented as a UIMA (Unstructured Information Management Architecture) component. Using one of several matching algorithms, it maps entries in a dictionary onto input documents, producing UIMA annotations.
		</p></div><div class="chapter" lang="en" id="usingcm"><div class="titlepage"><div><div><h2 class="title"><a name="usingcm"></a>Chapter&nbsp;1.&nbsp;Using ConceptMapper</h2></div></div></div><p>
			ConceptMapper was designed to provide highly accurate mappings of text into controlled vocabularies, specified as dictionaries, including the association of any necessary properties from the controlled vocabulary as part of that mapping. Individual dictionary entries could contain multiple terms (tokens), and ConceptMapper can be configured to allow multi-term entries to be matched against non-contiguous text. It was also designed to perform fast, and has been easily able to provide real-time results even with multi-million entry dictionaries.
		</p><p>
			Lookups are token-based, and are limited to applying within a specific context, usually a sentence, though this is configurable (e.g., a noun phrase, a paragraph or other NLP-based concept).
		</p></div><div class="chapter" lang="en" id="config"><div class="titlepage"><div><div><h2 class="title"><a name="config"></a>Chapter&nbsp;2.&nbsp;Functionality</h2></div></div></div><p>
			There are many parameters to configure all aspects of ConceptMapper's functionality, in terms of:				
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						processing the dictionary
					</p></li><li><p>
						the way input documents are processed
					</p></li><li><p>
						the availability of multiple lookup strategies
					</p></li><li><p>
						its various output options
					</p></li></ul></div><p>			
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dict"></a>2.1.&nbsp;Dictionaries</h2></div></div></div><p>The requirements on the design of the ConceptMapper dictionary were that it be easily extensible and that arbitrary properties could be associated with individual entries. Additionally, the set of properties could not be fixed, but rather customizable for any particular application.
			</p><p>
			The structure of a ConceptMapper dictionary is quite flexible and is expressed using XML (see <a href="#ConceptMapper.fig.dictentry" title="Example&nbsp;2.1.&nbsp;Sample dictionary entry">Example&nbsp;2.1, &#8220;Sample dictionary entry&#8221;</a>). Specifically, it consists of a set of entries, specified by the &lt;token&gt; XML tag, each containing one or more variants (synonyms), the text of which is specified using by the "base" feature of the &lt;variant&gt; XML tag. Entries can have any number of associated properties, as needed. Individual variants (synonyms) inherit features from their parent token (i.e., the canonical form), but can override any or all of them, or even add additional features.
		</p><p>
			In the following sample dictionary entry, there are 6 variants, and according to the rules described earlier, each inherits the all attributes from the canonical form (canonical, CodeType, CodeValue, and SemClass), though the variants &#8220;colonic&#8221; and &#8220;colic&#8221; override the value of the POS (part of speech) attribute:
		</p><p>
			</p><div class="example"><a name="ConceptMapper.fig.dictentry"></a><div class="example-contents"><pre class="programlisting">
			&lt;token canonical="colon, nos"
			       CodeType="ICDO" CodeValue="C18.9"
			       SemClass="Site" POS="NN"&gt;
				&lt;variant base=&#8221;colon, nos&#8221;/&gt;
				&lt;variant base=&#8221;colon&#8221;/&gt;
				&lt;variant base="colonic" POS="JJ" /&gt;
				&lt;variant base="colic" POS="JJ" /&gt;
				&lt;variant base="large intestine" /&gt;
				&lt;variant base="large bowel" /&gt;
			&lt;/token&gt;</pre></div><p class="title"><b>Example&nbsp;2.1.&nbsp;Sample dictionary entry</b></p></div><p><br class="example-break">
		</p><p>
			The result of running ConceptMapper are UIMA annotations, and there are two configuration parameters that are used to map the attributes from the dictionary (see <a href="#ConceptMapper.param.attributelist">AttributeList</a>) to features of UIMA annotations (see <a href="#ConceptMapper.param.featurelist">FeatureList</a>).
		</p><p>
			The entire dictionary is loaded into memory, which, in conjunction with an efficient data structure, provides very fast lookups. As stated earlier, dictionaries with millions of entries have been used without any performance issues. The obvious drawback to storing the dictionary in memory is that large dictionaries require large amounts of memory; this is partially mitigated by the fact that the dictionary is implemented as a UIMA shared resource (see <a href="#ConceptMapper.res.dictionaryfile">DictionaryFile</a>). This means that multiple annotators, such as multiple instances of ConceptMapper that are set up using different parameters, can all access it without having to load it more than once. The dictionary loader is specified in the external resource section of the descriptor, and is expected to implement the interface <code class="interfacename">org.apache.uima.conceptMapper.support.dictionaryResource.DictionaryResource</code>. Two implementations are included in the distribution, <code class="classname">org.apache.uima.conceptMapper.support.dictionaryResource.DictionaryResource_impl</code>, the standard implementation, which loads an XML version of a dictionary, and <code class="classname">org.apache.uima.conceptMapper.support.dictionaryResource.CompiledDictionaryResource_impl</code> which loads a pre-compiled version, for faster loading. The compiler is supplied as <code class="classname">org.apache.uima.conceptMapper.dictionaryCompiler.CompileDictionary</code>, which takes two arguments, a ConceptMapper analysis engine descriptor that loads the dictionary using the standard dictionary loader, and the name of the output file into which to write the compiled dictionary.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tokenizer"></a>2.2.&nbsp;Dictionary Entry Tokenization</h2></div></div></div><p>Input documents are processed on a token-by-token basis, so it is important that the dictionary entries are tokenized in the same way as the input documents. To accomplish this, ConceptMapper allows any UIMA analysis engine to be specified as the tokenizer for the dictionary entries. See parameter <a href="#ConceptMapper.param.tokenizerdescriptorpath">TokenizerDescriptorPath</a> for details.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paramInput"></a>2.3.&nbsp;Input Document Processing</h2></div></div></div><p>As stated earlier, input documents are processed on a token-by-token basis. Tokens are processed one span (e.g., a sentence or a noun phrase) at a time. Token annotations are specified by the parameter <a href="#ConceptMapper.param.tokenannotation">TokenAnnotation</a>, while span annotations are specified by the parameter <a href="#ConceptMapper.param.spanfeaturestructure">SpanFeatureStructure</a>. By default, all tokens within a span are considered, and it is the text associated with each token that is used for lookups. ConceptMapper can also be configured to consider tokens differently:
				
				</p><div class="itemizedlist"><ul type="disc"><li><p>
							Case sensitive or insensitive matching. See the parameter <a href="#ConceptMapper.param.casematch">caseMatch</a>
						</p></li><li><p>
							Stop words: ignore token during lookup if it appears in given stop word list. See the parameter <a href="#ConceptMapper.param.stopwords">StopWords</a>
						</p></li><li><p>
						Stemming: a stemmer can be specified to be applied to the text of the token. In practice, the stemmer could be a standard stemmer providing the root form of the token, or it could perform other functions, such as abbreviation expansion or spelling variant replacement. See the parameter <a href="#ConceptMapper.param.stemmer">Stemmer</a>
						</p></li><li><p>
						Use a token feature instead of the token's text. This is useful for cases where, for example, spelling or case correction results need to be applied instead of the token&#8217;s original text. See the parameter <a href="#ConceptMapper.param.tokentextfeaturename">TokenTextFeatureName</a>
						</p></li><li><p>
							skip tokens during lookups based on particular feature values, as described below
						</p></li></ul></div><p>
				
			</p><p>
			The ability to skip tokens during lookups based on particular feature values makes it easy to skip, for example, all tokens with particular part of speech tags, or with some previously computed semantic class. For example, given the text below in <a href="#ConceptMapper.fig.preskip" title="Example&nbsp;2.2.&nbsp;Sample Input Text">Example&nbsp;2.2, &#8220;Sample Input Text&#8221;</a>:
			</p><p>
				</p><div class="example"><a name="ConceptMapper.fig.preskip"></a><div class="example-contents"><pre class="programlisting">
				Infiltrating mammary carcinoma</pre></div><p class="title"><b>Example&nbsp;2.2.&nbsp;Sample Input Text</b></p></div><p><br class="example-break">
			</p><p>
				Assume each word is a token that has a feature SemanticClass, and that feature for the token &#8220;mammary&#8221; contains the value &#8220;AnatomicalSite&#8221;, while the tokens &#8220;Infiltrating&#8221; and &#8220;carcinoma&#8221; do not. It is then possible to configure ConceptMapper to indicate that tokens that have a particular feature, in this case SemanticClass, equal to one of a set of values, in this case &#8220;AnatomicalSite&#8221;, should be excluded when performing dictionary lookups (see parameters <a href="#ConceptMapper.param.excludedtokenclasses">ExcludedTokenClasses</a> and <a href="#ConceptMapper.param.excludedtokentypes">ExcludedTokenTypes</a>). By doing this, for the purposes of dictionary lookup, the example text would effectively appear to be:
			</p><p>	
				</p><div class="example"><a name="ConceptMapper.fig.skip"></a><div class="example-contents"><pre class="programlisting">
				Infiltrating carcinoma</pre></div><p class="title"><b>Example&nbsp;2.3.&nbsp;Result of Token Skipping</b></p></div><p><br class="example-break">
			</p><p>				
				In addition to the set of feature values that indicate their associated token are to be excluded during lookup, there are also configuration parameters that can be used to specify a set of feature values for inclusion (see parameters <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a> and <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a>). The algorithm for selecting annotations to include during lookup is as follows:
			</p><div class="example"><a name="ConceptMapper.fig.algo"></a><div class="example-contents"><pre class="programlisting">
				if there is an includeList but no excludeList
				include annotation if feature value in includeList

				else if there is an excludeList
				exclude annotation if feature value in excludeList

				else
				include annotation</pre></div><p class="title"><b>Example&nbsp;2.4.&nbsp;Token Selection Algorithm</b></p></div><br class="example-break"><p>
				This provides a simple way to restrict the selection of pre-classified tokens, whether that pre-classification is done via previous instances of ConceptMapper or some altogether different annotator.  See <a href="#ConceptMapper.param.tokentextfeaturename">TokenTextFeatureName</a>
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paramLookup"></a>2.4.&nbsp;Lookup Strategies</h2></div></div></div><p>The actual dictionary lookup algorithm is controlled by three parameters. One specifies token-order independent lookup (<a href="#ConceptMapper.param.orderindependentlookup">OrderIndependentLookup</a>). For example, a dictionary entry that contained the variant:
			</p><p>
				</p><pre class="programlisting">
			&lt;variant base='carcinoma, infiltrating'/&gt;</pre><p>
			</p><p>

			would also match against any permutation of its tokens. In this case, assuming that punctuation was ignored, it would match against both &#8220;infiltrating carcinoma&#8221; and &#8220;carcinoma, infiltrating&#8221;. Clearly, this particular setting must be used with care to prevent incorrect matches from being found, but for some domains it enables the use of a more compact dictionary, as all permutations of a particular entry do not need to be enumerated.
			</p><p>
			Another parameter that controls the dictionary lookup algorithm toggles between finding only the longest match vs. finding all possible matches (<a href="#ConceptMapper.param.findallmatches">FindAllMatches</a>). For the text:
			</p><p>
				</p><pre class="programlisting">
			... carcinoma, infiltrating ...</pre><p>
			</p><p>
			If there was a dictionary entry for &#8220;carcinoma&#8221; as well as the entry for &#8220;carcinoma, infiltrating&#8221;, this parameter would control whether only the latter was annotated as a result or both would be annotated. Using the setting that indicates all possible matches should be found is useful when subsequent disambiguation is required.
			</p><p>
			The final parameter that controls the dictionary lookup algorithm specifies the search strategy (<a href="#ConceptMapper.param.searchstrategy">SearchStrategy</a>), of which there are three. The default search strategy only considers contiguous tokens (not including tokens from the stop word list or otherwise skipped tokens, as described above), and then begins the subsequent search after the longest match. The second strategy allows for ignoring non-matching tokens, allowing for disjoint matches, so that a dictionary entry of
			</p><p>
				</p><pre class="programlisting">
			    A C</pre><p>
			</p><p>
			would match against the text
			</p><p>
				</p><pre class="programlisting">
			    A B C</pre><p>
			</p><p>
			This can be used as alternative method for finding &#8220;infiltrating carcinoma&#8221; over the text &#8220;infiltrating mammary carcinoma&#8221;, as opposed to the method described above, wherein the token &#8220;mammary&#8221; had to have been have been somehow pre-marked with a feature and that feature listed as indicating the token should be skipped. On the other hand, this approach is less precise, potentially finding completely disjoint and unrelated tokens as a dictionary match. As with the default search strategy, the subsequent search begins after the longest match.
			</p><p>
			The final search strategy is identical to the previous, except that subsequent searches begin one token ahead, instead of after the previous match. This enables overlapped matching. As with the setting that finds all matches instead of the longest match, using this setting is useful when subsequent disambiguation is required.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paramOutput"></a>2.5.&nbsp;Output Options</h2></div></div></div><p>Output is in the form of new UIMA annotations. As previously discussed, the mapping from dictionary entry attributes to the result annotation features can also be specified. 
			Given the fact that dictionary entries can have multiple variants, and that matches could contain non-contiguous sets of tokens, it can be useful to be able to be able to know exactly what was matched. There are two parameters that can be used to provide this information. One allows the specification of a feature in the output annotation that will be set to the string containing the matched text. The other can be used to indicate a feature to be filled with the list of tokens that were matched. Going back to the example in figure 2, where the token &#8220;mammary&#8221; was skipped, the matched string would be set to &#8220;Infiltrating carcinoma&#8221; and the matched tokens would be set to the list of tokens &#8220;Infiltrating&#8221; and &#8220;carcinoma&#8221;.
			</p><p>
			Another output control AE descriptor parameter  can be used to specify a feature of the resultant annotation to be set to contain the span annotation enclosing the matched token. Assuming, for example, that the spans being processed are sentences, this provides a convenient way to link the resultant annotation back to its enclosing sentence.
			</p><p>
			 It is also possible to indicate dictionary attributes to store back into each of the matched tokens. This provides the ability for tokens to be marked with information regarding what it was matched against. Going back to the example in figure 2, one way that the SemanticClass  feature  of the token &#8220;mammary&#8221; could have been labeled with the value &#8220;AnatomicalSite&#8221; was using this technique: a previous invocation of ConceptMapper had &#8220;mammary&#8221; as a dictionary entry, that entry had the SemanticClass feature with the value &#8220;AnatomicalSite&#8221;, and SemanticClass was listed as an attribute to write back as a token feature. If, instead of &#8220;mammary&#8221; the match was against a multi-token entry, then each of the multiple tokens would have that feature set.
			</p></div></div><div class="chapter" lang="en" id="configParams"><div class="titlepage"><div><div><h2 class="title"><a name="configParams"></a>Chapter&nbsp;3.&nbsp;Configuration Parameters</h2></div></div></div><p>
			Detailed description of all configuration parameters:	
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						<code class="varname"><a name="ConceptMapper.param.tokenizerdescriptorpath"></a>TokenizerDescriptorPath</code>: <span class="emphasis"><em>[Required]</em></span> <span class="type">String</span>
					</p><p>Path to tokenizer Analysis Engine descriptor, which is used to tokenize dictionary entries.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.languageid"></a>LanguageID</code>: <span class="emphasis"><em>[Required]</em></span> <span class="type">String</span>
					</p><p>Language ID (ISO 639-2), for use by the tokenizer specified by <a href="#ConceptMapper.param.tokenizerdescriptorpath">TokenizerDescriptorPath</a>.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.tokenannotation"></a>TokenAnnotation</code>: <span class="emphasis"><em>[Required]</em></span> <span class="type">String</span>
					</p><p>Type of feature structure representing tokens in the input CAS.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.spanfeaturestructure"></a>SpanFeatureStructure</code>: <span class="emphasis"><em>[Required]</em></span> <span class="type">String</span>
					</p><p>Type of feature structure that corresponds to spans of
					data for processing (e.g. a sentence) in the input CAS.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.attributelist"></a>AttributeList</code>: <span class="emphasis"><em>[Required]</em></span> <span class="type">Array of Strings</span>
					</p><p>List of attribute names for XML dictionary entry record. Must correspond to parallel list <a href="#ConceptMapper.param.featurelist">FeatureList</a>.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.featurelist"></a>FeatureList</code>: <span class="emphasis"><em>[Required]</em></span> <span class="type">Array of Strings</span>
					</p><p>List of feature names for <a href="#ConceptMapper.param.resultingannotationname">ResultingAnnotationName</a>. Must correspond to parallel list <a href="#ConceptMapper.param.attributelist">AttributeList</a>.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.casematch"></a>caseMatch</code>: <span class="emphasis"><em>[Required]</em></span> <span class="type">String</span>
					</p><p>
						Specifies the case folding mode. The following are the allowable values:
						</p><div class="itemizedlist"><ul type="circle"><li><code class="constant">ignoreall</code> - fold everything to lowercase for matching
							</li><li><code class="constant">insensitive</code> - fold only tokens with initial caps to lowercase
							</li><li><code class="constant">digitfold</code> - fold all (and only) tokens with a digit
							</li><li><code class="constant">sensitive</code> - perform no case folding
							</li></ul></div><p>
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.stopwords"></a>StopWords</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Array of Strings</span>
					</p><p>A list of words that are always to be ignored in dictionary lookups.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.stemmer"></a>Stemmer</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of stemmer class to use before matching. <span class="emphasis"><em>Must</em></span> implement the <code class="interfacename">org.apache.uima.conceptMapper.support.stemmer</code> interface and
						have a zero-parameter constructor. If not specified,
						no stemming will be performed.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.tokentextfeaturename"></a>TokenTextFeatureName</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of feature of token annotation that contains the token's text. If not specified, the token's covered text will be used.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.tokenclassfeaturename"></a>TokenClassFeatureName</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of feature used when doing lookups against <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a> and <a href="#ConceptMapper.param.excludedtokenclasses">ExcludedTokenClasses</a>. Values contained in this feature are of type <span class="type">String</span>. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>This parameter is mandatory if either <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a> or <a href="#ConceptMapper.param.excludedtokenclasses">ExcludedTokenClasses</a> are specified. See <a href="#ConceptMapper.fig.algo" title="Example&nbsp;2.4.&nbsp;Token Selection Algorithm">Example&nbsp;2.4, &#8220;Token Selection Algorithm&#8221;</a> for a description of how these are used during lookup.</div><p>
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.tokentypefeaturename"></a>TokenTypeFeatureName</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of feature used when doing lookups against <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a> and <a href="#ConceptMapper.param.excludedtokentypes">ExcludedTokenTypes</a>. Values contained in this feature are of type <span class="type">Integer</span>. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>This parameter is mandatory if either <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a> or <a href="#ConceptMapper.param.excludedtokentypes">ExcludedTokenTypes</a> are specified See <a href="#ConceptMapper.fig.algo" title="Example&nbsp;2.4.&nbsp;Token Selection Algorithm">Example&nbsp;2.4, &#8220;Token Selection Algorithm&#8221;</a> for a description of how these are used during lookup.</div><p>
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.includedtokentypes"></a>IncludedTokenTypes</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Array of Integers</span>
					</p><p>
						Type of tokens to include in lookups (if not
						supplied, then all types are included except those
						specifically mentioned in <a href="#ConceptMapper.param.excludedtokentypes">ExcludedTokenTypes</a>)
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.excludedtokentypes"></a>ExcludedTokenTypes</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Array of Integers</span>
					</p><p>
						Type of tokens to exclude from lookups (if not
						supplied, then all types are excluded except those
						specifically mentioned in <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a>,
						unless <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a> is not supplied, in
						which case none are excluded)
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.includedtokenclasses"></a>IncludedTokenClasses</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Array of Strings</span>
					</p><p>
						Class of tokens to include in lookups (if not
						supplied, then all classes are included except those
						specifically mentioned in <a href="#ConceptMapper.param.excludedtokenclasses">ExcludedTokenClasses</a>)
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.excludedtokenclasses"></a>ExcludedTokenClasses</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Array of Strings</span>
					</p><p>
						Class of tokens to exclude from lookups (if not
						supplied, then all classes are excluded except those
						specifically mentioned in <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a>,
						unless <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a> is not supplied, in
						which case none are excluded).
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.orderindependentlookup"></a>OrderIndependentLookup</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Boolean</span>
					</p><p>
						If "True", token (as specified by <a href="#ConceptMapper.param.tokenannotation">TokenAnnotation</a>) ordering within span (as specified by <a href="#ConceptMapper.param.spanfeaturestructure">SpanFeatureStructure</a>) is ignored during lookup
						(i.e., "top box" would equal "box top"). Default is
						False.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.searchstrategy"></a>SearchStrategy</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Specifies the dictionary lookup strategy. The following are the allowable values:
						</p><div class="itemizedlist"><ul type="circle"><li><code class="constant">ContiguousMatch</code> - longest
								match of contiguous tokens (as specified by <a href="#ConceptMapper.param.tokenannotation">TokenAnnotation</a>) within enclosing
								span (as specified by <a href="#ConceptMapper.param.spanfeaturestructure">SpanFeatureStructure</a>), taking into account included/excluded items (see <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a>,  <a href="#ConceptMapper.param.excludedtokentypes">ExcludedTokenTypes</a>,  <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a> and  <a href="#ConceptMapper.param.excludedtokenclasses">ExcludedTokenClasses</a>).
								DEFAULT strategy
							</li><li><code class="constant">SkipAnyMatch</code> - longest match of
								not-necessarily contiguous tokens (as specified by <a href="#ConceptMapper.param.tokenannotation">TokenAnnotation</a>) within enclosing
								span (as specified by <a href="#ConceptMapper.param.spanfeaturestructure">SpanFeatureStructure</a>), taking into account included/excluded items (see <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a>,  <a href="#ConceptMapper.param.excludedtokentypes">ExcludedTokenTypes</a>,  <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a> and  <a href="#ConceptMapper.param.excludedtokenclasses">ExcludedTokenClasses</a>).
								Subsequent lookups begin in span after complete
								match. <span class="emphasis"><em>Implies</em></span> order-independent lookup (see <a href="#ConceptMapper.param.orderindependentlookup">OrderIndependentLookup</a>).
							</li><li><code class="constant">SkipAnyMatchAllowOverlap</code> - longest match of
								not-necessarily contiguous tokens (as specified by <a href="#ConceptMapper.param.tokenannotation">TokenAnnotation</a>) within enclosing
								span, (as specified by <a href="#ConceptMapper.param.spanfeaturestructure">SpanFeatureStructure</a>) taking into account included/excluded items (see <a href="#ConceptMapper.param.includedtokentypes">IncludedTokenTypes</a>,  <a href="#ConceptMapper.param.excludedtokentypes">ExcludedTokenTypes</a>,  <a href="#ConceptMapper.param.includedtokenclasses">IncludedTokenClasses</a> and  <a href="#ConceptMapper.param.excludedtokenclasses">ExcludedTokenClasses</a>).
								Subsequent lookups begin in span after next token.
								<span class="emphasis"><em>Implies</em></span> order-independent lookup (see <a href="#ConceptMapper.param.orderindependentlookup">OrderIndependentLookup</a>).
							</li></ul></div><p>
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.findallmatches"></a>FindAllMatches</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Boolean</span>
					</p><p>
						If True, all dictionary matches are found within the span specified by <a href="#ConceptMapper.param.spanfeaturestructure">SpanFeatureStructure</a>, otherwise only the longest matches are found.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.resultingannotationname"></a>ResultingAnnotationName</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of the annotation type created by this TAE.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.resultingenclosingspanname"></a>ResultingEnclosingSpanName</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of the feature in the <a href="#ConceptMapper.param.resultingannotationname">ResultingAnnotationName</a> that will be set to point to the span annotation that encloses it (i.e. its
						sentence)
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.resultingannotationmatchedtextfeature"></a>ResultingAnnotationMatchedTextFeature</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of the feature in the <a href="#ConceptMapper.param.resultingannotationname">ResultingAnnotationName</a> that will be set to the string that was matched  in the dictionary. This could be different that the annotation's covered text if there were any skipped tokens in the match.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.matchedtokensfeaturename"></a>MatchedTokensFeatureName</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">String</span>
					</p><p>
						Name of the FSArray feature in the <a href="#ConceptMapper.param.resultingannotationname">ResultingAnnotationName</a> that will set to the set of tokens matched.
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.tokenclasswritebackfeaturenames"></a>TokenClassWriteBackFeatureNames</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Array of Strings</span>
					</p><p>
						Names of features in the <a href="#ConceptMapper.param.resultingannotationname">ResultingAnnotationName</a> that should be written back to a token from the matching dictionary entry, such as a POS tag. 
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.param.printdictionary"></a>PrintDictionary</code>: <span class="emphasis"><em>[Optional]</em></span> <span class="type">Boolean</span>
					</p><p>
						If True, print dictionary after loading. Default is False. 
					</p></li><li><p>
						<code class="varname"><a name="ConceptMapper.res.dictionaryfile"></a>DictionaryFile</code>: <span class="emphasis"><em>[Dictionary Resource]</em></span> <span class="type">Boolean</span>
					</p><p>
						Dictionary file resource specification. Specify class name for dictionary loader, then bind to name of file containing dictionary contents to be loaded.
					</p></li></ul></div></div></div></body></html>