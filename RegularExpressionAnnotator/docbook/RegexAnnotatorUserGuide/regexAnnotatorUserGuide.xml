<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY imgroot "./images/" >
<!ENTITY % xinclude SYSTEM "../../../uima-docbook-tool/xinclude.mod">
  %xinclude;
]>
<!--
	Licensed to the Apache Software Foundation (ASF) under one
	or more contributor license agreements.  See the NOTICE file
	distributed with this work for additional information
	regarding copyright ownership.  The ASF licenses this file
	to you under the Apache License, Version 2.0 (the
	"License"); you may not use this file except in compliance
	with the License.  You may obtain a copy of the License at
	
	http://www.apache.org/licenses/LICENSE-2.0
	
	Unless required by applicable law or agreed to in writing,
	software distributed under the License is distributed on an
	"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, either express or implied.  See the License for the
	specific language governing permissions and limitations
	under the License.
-->

<book lang="en">

	<title>
		Apache UIMA Regular Expression Annotator Documentation
	</title>

	<xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
		href="../../../SandboxDocs/src/docbook/book_info.xml" />

	<preface>
		<title>Introduction</title>
		<para>
			The Regular Expression Annotator (RegexAnnotator) is an
			Apache UIMA analysis engine that detects entities such as
			email addresses, URLs, phone numbers, zip codes or any other
			entity that can be specified using a regular expression. For
			each entity that is detected an own annotation can be
			created or an already existing annotation can be updated
			with new features.

			To detect also more difficult and complex entities, the
			annotator provides some advanced filter capabilities and a
			rule definition syntax that can combine rules to a concept
			with a confidence value for each of the concept's rules.
		</para>
	</preface>

	<chapter id="sandbox.regexAnnotator.processingOverview">
		<title>Processing Overview</title>
		<para>
			To detect any kind of entity the RegexAnnotator must be
			configured using an external XML file. We call this file
			"concept file" since it contains the regular expressions and
			concepts that the annotator use during its processing to
			detect entities. In addition to the rules the concept file
			also contains the "entity result processing" that is done if
			an entity was detected. The "entity result processing" can
			either be the creation of new annotations or an update of an
			existing annotation with additional features. The types and
			features that are used to create new annotations have to be
			available in the UIMA type system.
		</para>
		<para>
			After the concept file is created, the annotator XML
			descriptor have to be updated with the capabilities and
			maybe with the type system information from the concept
			file. The capability update is necessary that the UIMA
			framework can call the annotator also in complex annotator
			flows if the annotator is assembled with others to an
			analysis bundle. The UIMA type system update is only
			necessary if the used types are not available in the UIMA
			type system definition.
		</para>
		<para>
			With the completion of the descriptor updates, the
			RegexAnnotator is ready to use. When starting the annotator,
			during the initialization the annotator reads the concept
			file and checks if all rules and concepts are valid and if
			all annotations types are defined in the UIMA type system.
			For each document that is processed the rules and concepts
			are executed in exactly the same order as defined in the
			concept file. The results and annotations created for a
			preceding rule are used by the following one since they are
			stored in the CAS.
		</para>
	</chapter>
	<chapter id="sandbox.regexAnnotator.conceptsFile">
		<title>Concepts Configuration File</title>
		<para>
			The RegexAnnotator can be configured using two levels of
			complexity.
		</para>
		<para>
			The RuleSet definition is the easier way to define rules.
			Such a definition consists of a regular expression pattern
			and of annotations that should be created if the rule match
			an entity.
		</para>
		<para>
			The Concept definition is the more complex way to define
			rules. Such a definition can consists of more than one
			regular expression rule that can be combined together and of
			a set of annotations that should be created if one of the
			rules has matched an entity.
		</para>
		<para>
			The syntax for both definitions is the same, so you don't
			need to learn two configuration possibilities. The RuleSet
			definition is just available to have an easier and faster
			way to configure the annotator for simple tasks. If you have
			a RuleSet definition it is also possible to extend it with
			more and more features so that it becomes a real Concept
			definition.
		</para>

		<section id="sandbox.regexAnnotator.conceptsFile.rules">
			<title>RuleSet definition</title>
			<para>
				The syntax of a simple RuleSet definition for the
				RegexAnnotator is shown in the listing below:
			</para>
			<para>

<programlisting><![CDATA[<conceptSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:noNamespaceSchemaLocation="concept.xsd">

  <concept name="RuleSetDefinitionExample">
    <rules>
      <rule regEx="ExamplePattern" matchStrategy="matchAll" 
          matchType="uima.tcas.DocumentAnnotation"/>
    </rules>
    <createAnnotations>
      <annotation id="MyAnnotation" type="org.apache.uima.MyAnnotation">
        <begin group="0"/>
        <end group="0"/>
      </annotation>
    </createAnnotations>
  </concept>

</conceptSet>
]]></programlisting>
			</para>
			<para>
				The definition above defines are simple concept
				with the name <code>RuleSetDefinitionExample</code>. The 
				defined rule use the <code>ExamplePattern</code> as 
				regular expression pattern that is matched on the
				covered text of the match type <code>uima.tcas.DocumentAnnotation</code>. 
				As match strategy, <code>matchAll</code> is used that means that all
				matches for the pattern are used to create the
				annotations defined in the
				<code>&lt;createAnnotations></code>
				element. So for each match a
				<code>org.apache.uima.MyAnnotation</code> annotation is created that
				covers the match in the document text.
			</para>
			<para>
				For additional annotation creation possibilities such as adding
				features to a created annotation, please refer to 
				<xref linkend="sandbox.regexAnnotator.conceptsFile.annotationCreation"/>
			</para>
		</section>

		<section id="sandbox.regexAnnotator.conceptsFile.concepts">
			<title>Concept definition</title>
			<para>The syntax of a complex Concept definition for the 
			  RegexAnnotator is shown in the listing below:</para>
			<para>
			
			<programlisting><![CDATA[<conceptSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:noNamespaceSchemaLocation="concept.xsd">

  <concept name="complexConceptExample">
    <rules>
      <rule ruleId="Id1" regEx="PatternExample1" matchStrategy="matchAll" 
          matchType="uima.tcas.DocumentAnnotation" confidence="1.0"/>
      <rule ruleId="Id2" regEx="PatternExample2" matchStrategy="matchAll" 
          matchType="uima.tcas.DocumentAnnotation" confidence="0.7"/>
      <rule ruleId="Id3" regEx="PatternExample3" matchStrategy="matchAll" 
          matchType="uima.tcas.DocumentAnnotation" confidence="0.3"/>
    </rules>
    <createAnnotations>	
      <annotation id="myAnnotation" type="org.apache.uima.MyAnnotation">
        <begin group="0"/>
        <end group="0"/>
        <setFeature name="confidenceValue" type="Confidence"/>
        <setFeature name="ruleId" type="RuleId"/>
      </annotation>
    <createAnnotations>
  </concept>

</conceptSet>
]]></programlisting>
				
			</para>
			<para>
				As you can see the Concept definition is a more complex
				RuleSet definition. The main differences are some additional
				features defined at the rule and the combination of rules 
				within one concept. 
				The new features for a rule are <code>ruleID</code>
				and <code>confidence</code>. If these features
				are specified, the feature values for these features can 
				later be assigned to an annotation feature for a created annotation. 
				In case we use the listing above as example this means that when the 
				<code>org.apache.uima.MyAnnotation</code> is created the value of the
				<code>confidence</code> feature of the rule that matched the document text 
				is assigned to the annotation feature called <code>confidenceValue</code>.
				The same is done for the <code>ruleId</code> feature.
				With that you can later check your annotation confidence and you can see 
				which rule was responsible for the annotation creation.
			</para>
			<note>
				<para>
					The annotation features for <code>Confidence</code>
					and <code>RuleId</code>
					have to be created manually in the UIMA type system.
					Given that it is possible to assign the <code>confidence</code> and <code>ruleId</code> 
					feature values to any other annotation feature you have defined 
					in the UIMA type system. Confidence features have to be of type
					<code>uima.cas.Float</code> and RuleId features have to be of
					type <code>uima.cas.String</code>.
				</para>
			</note>
			
			<para>
				The processing of a concept definition depends on a parameter setting
				that can be changed in the RegexAnnotator descriptor. 
				The parameter that controls the processing is called
				<code>ProcessAllConceptRules</code>.
				By default this parameter is set to	<code>false</code>. 
				This means that the concept processing 
				starts with the	first rule and goes on with the next one 
				until a match was found. So in this processing mode, maybe only the first rule
				of a concept is evaluated if there a match was found. The other rules
				of this concept will be ignored in that case.
				This strategy should be used for example if your first concept 
				rule has a strict pattern with a confidence of 1.0 and your 
				second rule has a more lenient pattern with a confidence
				of 0.5. If the <code>ProcessAllConceptRules</code> parameter
				is set to <code>true</code>	all rules of a concept are processed 
				independent of the matches for a previous rule.
			</para>

		</section>

		<section
			id="sandbox.regexAnnotator.conceptsFile.rulesDefinition">
			<title>Rule Definition</title>
			<para>
				This paragraph shows in detail how to define a rule for a 
				RuleSet or Concept definition and give you some advanced 
				configuration possibilities	for the rule processing.
			</para>
			<para>
				The listing below shows a complex rule definition with
				all the possible sub elements and details. Please refer to
				the sub sections for the details about the sub elements.
			</para>
			<para> 
<programlisting><![CDATA[<rule ruleId="ID1" regEx="TestRegex" matchStrategy="matchAll" 
    matchType="uima.tcas.DocumentAnnotation" confidence="1.0">

  <matchTypeFilter>
    <feature name="language">en</feature>
  </matchTypeFilter>

  <updateMatchTypeAnnotation>
    <setFeature name="language" type="String">$0</setFeature>
  </updateMatchTypeAnnotation>	

  <ruleExceptions>	
    <exception matchType="uima.tcas.DocumentAnnotation">
        Exception
    </exception>
  </ruleExceptions>

</rule>
]]></programlisting>
			</para>
			
			<para>
				For each rule that should be added a <code>&lt;rule></code> element
				have to be created. The <code>&lt;rule></code> element definition has three 
				mandatory features, these are:
			</para>
				<para>
					<itemizedlist>
						<listitem>
							<para>
								<code>regEx</code>
								- The regular expression pattern that
								is used for this rule. As pattern, everything supported 
								by the Java regular expression syntax is allowed.
							</para>
						</listitem>
						<listitem>
							<para>
								<code>matchStrategy</code>
								- The match strategy that is used
								for this rule. Possible values are
								<code>matchAll</code>
								to get all matches,
								<code>matchFirst</code>
								to get the first match only and
								<code>matchComplete</code>
								to get matches where the whole input
								text match the regular expression pattern.
							</para>
						</listitem>
						<listitem>
							<para>
								<code>matchType</code>
								- The annotation type that is used 
								to match the regular expression pattern.
								As input text for the match, the annotation span 
								is used.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					In addition to the mandatory features the <code>&lt;rule></code>
					element definition also has some optional features that can
					be used, these are:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<code>ruleId</code>
							- Specifies an unique ID for the rule. This
							ID can later be used to add it as
							value to an annotation feature (see
							<xref linkend="sandbox.regexAnnotator.conceptsFile.annotationCreation.features"/>).
						</para>
					</listitem>
					<listitem>
						<para>
							<code>confidence</code>
							- Specifies the confidence value of this
							rule. If you have more than one rule that describes 
							the same complex entity you can classify the rules with
							a confidence value. This confidence value
							can later be used to add it as value to an
							annotation feature (see
							<xref linkend="sandbox.regexAnnotator.conceptsFile.annotationCreation.features"/>).
						</para>
					</listitem>
				</itemizedlist>

			<section
				id="sandbox.regexAnnotator.conceptsFile.rulesDefinition.filter">
				<title>Match Type Filter</title>
				<para>
				<programlisting><![CDATA[<matchTypeFilter>
  <feature name="language">en</feature>
</matchTypeFilter>
]]></programlisting>
					

				</para>
				<para>
					Match type filters can be used to filter the match type
					annotations that are used for matching the regular expression
					pattern. For example to use a rule only when the document language 
					is English, as shown in the example above. 
					Match type filters ever relate to the <code>matchType</code>
					that was specified for the rule.
				</para>
				<para>
					The <code>&lt;matchTypeFilter></code>
					element can contain an arbitrary amount of
					<code>&lt;feature></code>
					elements that contains the filter information. But all specified features
					have to be valid for the <code>matchType</code> annotation
					of the rule.
				</para>
				<para>
					The name of the UIMA feature that should be used as 
					filter is specified using the <code>name</code> feature of the
					<code>&lt;feature></code> element. The content of the
					<code>&lt;feature></code> element contains the regular expression pattern 
					that is used as filter. This pattern 
					have to match the UIMA feature value of the match type annotation 
					that the filter pass. In the example
					above the match type annotation has a UIMA feature called 
					<code>language</code> that have to have the content <code>en</code>. If that
					is true, the annotation is pass the filter condition.
				</para>
			</section>
			<section id="sandbox.regexAnnotator.conceptsFile.rulesDefinition.update">
				<title>Update Match Type Annotations With Additional Features</title>
				<para>	
					<programlisting><![CDATA[<updateMatchTypeAnnotation>
  <setFeature name="language" type="String">$0</setFeature>
</updateMatchTypeAnnotation>
]]></programlisting>
				</para>
				<para>
					With the
					<code>&lt;updateMatchTypeAnnotation></code>
					construct it is possible to update or set a UIMA feature value
					for the match type annotation in case a rule match
					was found. The
					<code>&lt;updateMatchTypeAnnotation></code> element
					can have an arbitrary amount of
					<code>&lt;setFeature></code> elements that contains
					the feature information that should be updated.
				</para>
				<para>
					The	<code>&lt;setFeature></code> element has two 
					mandatory features, these are:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<code>name</code>
							- Specifies the UIMA feature name that
							should be set. The feature have to be available
							at the <code>matchType</code> annotation
							of the rule.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>type</code>
							- Specifies the UIMA feature type that is
							defined in the UIMA type system for this feature. 
							Currently supported feature types are <code>String</code>,
							<code>Integer</code> and <code>Float</code>.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					The content of the	<code>&lt;setFeature></code>
					element definition contains the feature value that should be set. 
					This can either be a literal value or a regular
					expression capturing group as shown in the example
					above. A combination of capturing groups and literals
					is also possible.
				</para>
			</section>
			<section
				id="sandbox.regexAnnotator.conceptsFile.rulesDefinition.exception">
				<title>Rule exception</title>
				<para>
					 
					<programlisting><![CDATA[<ruleExceptions>	
  <exception matchType="uima.tcas.DocumentAnnotation">
      ExceptionPattern
  </exception>
</ruleExceptions>
]]></programlisting>
					

				</para>
				<para>
					With the
					<code>&lt;ruleExceptions></code>
					construct it is possible to configure exceptions to prevent matches for the rule. 
					An exception is something similar to a filter, but on the higher level. For
					example take the scenario where you have several token annotations that
					are covered by a sentence annotation. You have written a rule that can detect
					car brands. The text you analyze has the sentence "Henry Ford was born 1863". 
					When analyzing the text you will get a car brand annotation since "Ford" is
					a car brand. But is this the correct behavior? The work around that issue
					you can create an exception that looks like
					 <programlisting><![CDATA[<ruleExceptions>	
  <exception matchType="uima.SentenceAnnotation">Henry</exception>
</ruleExceptions>
]]></programlisting>
					and add it to your car brand rule. After adding this, car brand annotations
					are only created if the sentence annotation that covers the token annotation
					does not contain the word "Henry". 					
				</para>
				<para>
					The	<code>&lt;ruleExceptions></code> element can have 
					an arbitrary amount of <code>&lt;exception></code>
					elements to specify rule exceptions.
				</para>
				<para>
					The <code>&lt;exception></code>
					element has one mandatory feature called
					<code>matchType</code>. The <code>matchType</code> feature
					specifies the annotation type the exception is based on. 
					The concrete exception match type annotation that is used 
					during the runtime is evaluated for each
					match type annotation that is used to match a rule. As
					exception annotation always the covering annotation
					of the current match type annotation is used. 
					If no covering annotation instance of the exception match type 
					was found the exception is not evaluated.
				</para>
				<para>
					The content of the <code>&lt;exception></code>
					element specifies the regular expression that is used to evaluate the exception.
				</para>
				<para>
					If the exception match is true, the
					current match type annotation is filtered out and is
					not used to create any matches and annotations.
				</para>
			</section>
		</section>
		<section id="sandbox.regexAnnotator.conceptsFile.annotationCreation">
				<title>Annotation Creation</title>
				<para>
				  This paragraph explains in detail how to create annotations if a rule has matched some input text.
				  An annotation creation example with all possible settings is shown in the listing below.
				</para>
				<para>
				<programlisting><![CDATA[<annotation id="testannot" type="org.apache.uima.TestAnnot">
	<begin group="0" location="start"/>
	<end group="0" location="end"/>
	<setFeature name="testFeature1" type="String">$0</setFeature>
	<setFeature name="testFeature2" type="Integer">$1</setFeature>
	<setFeature name="testFeature3" type="Float">$2</setFeature>		
	<setFeature name="testFeature4" type="Reference">testannot1</setFeature>
	<setFeature name="confidenceValue" type="Confidence"/>
	<setFeature name="ruleId" type="RuleId"/>
</annotation>
]]></programlisting>
				</para>
				
				<para>
				  The <code>&lt;annotation></code> element has two mandatory features, these are:
				</para>
				<para>
				<itemizedlist>
					<listitem>
						<para>
							<code>id</code>
							- Specifies the annotation id for this annotation. The id have to be unique within the
							concepts file.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>type</code>
							- Specifies the UIMA annotation type that is used if an annotation is created. 
							The used type have to be defined in the UIMA type system.
						</para>
					</listitem>
				</itemizedlist>
				</para>
				<para>
				  The mandatory sub elements of the <code>&lt;annotation></code> element are:
				</para>
				<para>
				<itemizedlist>
					<listitem>
						<para>
							<code>&lt;begin></code>
							- Specifies the begin position of the annotation that is created.
							For details about the <code>&lt;begin></code> element, please refer
							to the <xref linkend="sandbox.regexAnnotator.conceptsFile.annotationCreation.boundaries"/>.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>&lt;end></code>
							- Specifies the end position of the annotation that is created.
							For details about the <code>&lt;end></code> element, please refer
							to the <xref linkend="sandbox.regexAnnotator.conceptsFile.annotationCreation.boundaries"/>.
						</para>
					</listitem>
				</itemizedlist>
				</para>
				<para>
				  The optional sub elements of the <code>&lt;annotation></code> element are:
				</para>
				<para>
				<itemizedlist>
					<listitem>
						<para>
							<code><code>&lt;setFeature></code></code>
							- set a UIMA feature for the created annotation.
							For details about the <code>&lt;setFeature></code> element, please refer
							to the <xref linkend="sandbox.regexAnnotator.conceptsFile.annotationCreation.features"/>
						</para>
					</listitem>
				</itemizedlist>
				</para>
				<section id="sandbox.regexAnnotator.conceptsFile.annotationCreation.boundaries">
				<title>Annotation Boundaries</title>
				<para>
				  When creating an annotation with the <code>&lt;annotation></code> element it is also
				  necessary to define the annotations boundaries. The annotation boundaries are defined using the
				  sub elements <code>&lt;begin></code> and <code>&lt;end></code>. The start position of
				  the annotation is defined using the <code>&lt;begin></code> element, the end position using
				  the <code>&lt;end></code> element. Both elements have the same features as shown below:
				</para>
				<para>
				<itemizedlist>
					<listitem>
						<para>
							<code>group</code>
							- identifies the capturing group number within the regular expression pattern for the 
							current rule. The value can be a single number from 0 to 9, where 0 denotes 
							the whole match, 1 the first capturing group, 2 the second one, and so on.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>location</code>
							- indicates a position inside the capturing group, which can either be the position 
							of the left parenthesis in case of a value <code>start</code>, or the right parenthesis in 
							case of a value <code>end</code>. The <code>location</code> feature is optional. By default
							the <code>&lt;begin></code> element is set to <code>location="start"</code> and the 
							<code>&lt;end></code> element to <code>location="end"</code>.
						</para>
					</listitem>
				</itemizedlist>
				</para>
				</section>
				<section id="sandbox.regexAnnotator.conceptsFile.annotationCreation.features">
				<title>Annotation Features</title>
				<para>
				  With the <code>&lt;setFeature></code> element of <code>&lt;annotation></code> definition it is 
				  possible to set UIMA features for the created annotation. The mandatory features
				  for the <code>&lt;setFeature></code> element are: 
				</para>
				<para>
				<itemizedlist>
					<listitem>
						<para>
							<code>name</code>
							- specifies the UIMA feature name that should be set. The feature name have to 
							be a valid UIMA feature for this annotation and have to be defined in the
							UIMA type system.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>type</code>
							- specifies the type of the UIMA feature. For a list of all
							possible feature types please refer to 
							<xref linkend="sandbox.regexAnnotator.conceptsFile.annotationCreation.featureTypes"/>.
						</para>
					</listitem>
				</itemizedlist>
				</para>
				<para>
				  The content of the <code>&lt;setFeature></code> element specifies the value of the
				  UIMA feature that is set. As value a literal, a capturing group or a combination of
				  both can be used.
				</para>
				<section id="sandbox.regexAnnotator.conceptsFile.annotationCreation.featureTypes">
				<title>Features types</title>
				<para>
				  When setting UIMA feature for an annotation using the <code>&lt;setFeature></code> element 
				  the feature type has to be specified according the the UIMA type system definition.
				  The feature at the <code>&lt;setFeature></code> element to do that is called <code>type</code>.
				  The list below shows all currently supported feature types: 
				</para>
				<para>
				<itemizedlist>
					<listitem>
						<para>
							<code>String</code>
							- for <code>uima.cas.String</code> based UIMA features.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>Integer</code>
							- for <code>uima.cas.Integer</code> based UIMA features.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>Float</code>
							- for <code>uima.cas.Float</code> based UIMA features.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>Reference</code>
							- to link a UIMA feature to another annotation. In this case the
							UIMA feature type have to be the same as the referred annotation type.
							To reference another annotation the <code>&lt;setFeature></code>
							content have to contain the annotation <code>id</code> of the referred 
							annotation.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>Confidence</code>
							- to add the value of the <code>confidence</code> feature defined
							at the <code>&lt;rule></code> element to this feature. The UIMA feature have to
							be of type <code>uima.cas.Float</code>.
						</para>
					</listitem>
					<listitem>
						<para>
							<code>RuleId</code>
							- to add the value of the <code>ruleId</code> feature defined
							at the <code>&lt;rule></code> element to this feature. The UIMA feature have to
							be of type <code>uima.cas.String</code>.
						</para>
					</listitem>					
				</itemizedlist>
				</para>

				</section>
			</section>			
		</section>
</chapter>
<chapter id="sandbox.regexAnnotator.annotatorDescriptor">
			<title>Annotator Descriptor</title>
			<para>The RegexAnnotator analysis engine descriptor contains some processing information about 
			the annotator. This processing information is specified as parameters and external resource dependencies. 
			This chapter we explain in detail the possible descriptor settings.
			</para>
			<section id="sandbox.regexAnnotator.annotatorDescriptor.configParam">
				<title>Configuration Parameters</title>
				<para>
				  The RegexAnnotator has the following configuration parameters that can affect the processing: 
				</para>
				<para>
					<itemizedlist>
						<listitem>
							<para>
								<code>ProcessAllConceptRules</code>
								- By default this parameter is set to <code>false</code>. 
								This means that the concept processing
								starts with the	first rule (highest confidence) and goes on with the next one
								until a match was found. So in this processing mode, maybe only the first rule
								of a concept is evaluated if there a match was found. 
								The other rules of this concept will be ignored in that case.
								If the <code>ProcessAllConceptRules</code> parameter
								is set to <code>true</code>	all rules of a concept are processed 
								independent of the matches for a previous rule. 
							</para>
						</listitem>
				  	</itemizedlist>
				</para>
			</section>
			<section id="sandbox.regexAnnotator.annotatorDescriptor.externalResource">
				<title>External Resources</title>
				<para>
				  To specify the concept file the RegexAnnotator should use 
				  an external resource binding is used. 
				  The important section in the descriptor where the external resource
				  is specified is shown below.
				</para>
				<para>
				<programlisting><![CDATA[<externalResources>
  <externalResource>
    <name>RegexConceptsFile</name>
    <description>Regex Concepts file</description>
    <fileResourceSpecifier>
      <fileUrl>file:concepts.xml</fileUrl>
    </fileResourceSpecifier>
    <implementationName>
      org.apache.uima.annotator.regex.impl.FileResource_impl
    </implementationName>
  </externalResource>
</externalResources>
]]></programlisting>
				</para>
				<para>
				  The <code>&lt;fileUrl></code> element contains the file URL of the concept file.
				  The given URL have to be available in the UIMA datapath or in the classpath. 
				</para>
				
			</section>
			<section id="sandbox.regexAnnotator.annotatorDescriptor.capabilities">
				<title>Capabilities</title>
				<para>
				  In the capabilities section of the RegexAnnotator descriptor the input and output 
				  capabilities and the supported languages have to be defined. 
				</para>
				<para>
				  The input capabilities defined
				  in the descriptor have to comply with the match types used in the concept rule file 
				  that is used. For example the <code>uima.SentenceAnnotation</code> used in the rule
				  below have to be added to the input capability section in the RegexAnnotator descriptor.
				</para>
				<para>
				<programlisting><![CDATA[<rules>
  <rule regEx="SampleRegex" matchStrategy="matchAll" 
      matchType="uima.SentenceAnnotation"/>
</rules>
]]></programlisting>
				</para>
				<para>
				  In the output section, all of the annotation types and features created by 
				  the RegexAnnotator have to be specified. These have to match the 
				  output types and features declared in the <code>&lt;annotation></code> elements of the concept file.
				  For example the <code>org.apache.uima.TestAnnot</code> annotation and the 
				  <code>org.apache.uima.TestAnnot:testFeature</code> feature used below have to
				  be added to the output capability section in the RegexAnnotator descriptor. 
				</para>
				<para>
				<programlisting><![CDATA[<createAnnotations>
  <annotation id="testannotation" type="org.apache.uima.TestAnnot">
    <begin group="0"/>
    <end group="0"/>
    <setFeature name="testFeature" type="String">$0</setFeature>
  </annotation>
</createAnnotations>
]]></programlisting>
				</para>
				<para>
				  If there are any language dependent rules in the concept file the languages abbreviations 
				  have to be specified in the <code>&lt;languagesSupported></code>element. If there are no 
				  language dependent rules available you can specify <code>x-unspecified</code> as language. That means
				  that the annotator can work on all languages.   
				</para>
				<para>
				  For the short examples used above the capabilities section in the RegexAnnotator 
				  descriptor looks like:
				</para>
				<para>
				<programlisting><![CDATA[<capabilities>
  <capability>
    <inputs>
      <type>uima.SentenceAnnotation</type>
    </inputs>
    <outputs>
      <type>org.apache.uima.TestAnnot</type>
      <feature>org.apache.uima.TestAnnot:testFeature</feature>
    </outputs>
    <languagesSupported>
      <language>x-unspecified</language>
    </languagesSupported>
  </capability>
</capabilities>
]]></programlisting>
				</para>
			</section>
</chapter>
<appendix id="sandbox.regexAnnotator.xsd">
			<title>Concept File Schema</title>
			<para>The concept file schema that is used to define the concept file looks like:
			</para>
			<para>
				<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<!--
		* Licensed to the Apache Software Foundation (ASF) under one
		* or more contributor license agreements.  See the NOTICE file
		* distributed with this work for additional information
		* regarding copyright ownership.  The ASF licenses this file
		* to you under the Apache License, Version 2.0 (the
		* "License"); you may not use this file except in compliance
		* with the License.  You may obtain a copy of the License at
		* 
		*   http://www.apache.org/licenses/LICENSE-2.0
		* 
		* Unless required by applicable law or agreed to in writing,
		* software distributed under the License is distributed on an
		* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
		* KIND, either express or implied.  See the License for the
		* specific language governing permissions and limitations
		* under the License.
	-->

  <xs:element name="conceptSet">
	<xs:complexType>
	  <xs:sequence>
		<xs:element ref="concept" minOccurs="1"	maxOccurs="unbounded"/>
	  </xs:sequence>
	</xs:complexType>
  </xs:element>

  <xs:element name="concept">
	<xs:complexType>
	  <xs:sequence>
		<xs:element ref="rules" minOccurs="1" maxOccurs="1"/>
		<xs:element ref="createAnnotations" minOccurs="1" maxOccurs="1"/>
	  </xs:sequence>
	  <xs:attribute name="name" type="xs:ID" use="optional"/>
	</xs:complexType>
  </xs:element>

  <xs:element name="createAnnotations">
	<xs:complexType>
	  <xs:sequence>
		<xs:element ref="annotation" minOccurs="1" maxOccurs="unbounded"/>
	  </xs:sequence>
	</xs:complexType>
  </xs:element>

  <xs:element name="rules">
	<xs:complexType>
	  <xs:sequence>
		<xs:element ref="rule" minOccurs="1" maxOccurs="unbounded"/>
	  </xs:sequence>
	</xs:complexType>
  </xs:element>

  <xs:element name="rule">
	<xs:complexType>
	  <xs:all>
		<xs:element ref="matchTypeFilter" minOccurs="0"	maxOccurs="1"/>
		<xs:element ref="updateMatchTypeAnnotation" minOccurs="0" maxOccurs="1"/>
		<xs:element ref="ruleExceptions" minOccurs="0" maxOccurs="1"/>
	  </xs:all>
	  <xs:attribute name="regEx" type="xs:string" use="required"/>
	  <xs:attribute name="matchStrategy" use="required">
	    <xs:simpleType>
		  <xs:restriction base="xs:string">
		    <xs:enumeration value="matchFirst"/>
			<xs:enumeration value="matchAll"/>
			<xs:enumeration value="matchComplete"/>
		  </xs:restriction>
		</xs:simpleType>
	  </xs:attribute>
	  <xs:attribute name="matchType" type="xs:string" use="required"/>
	  <xs:attribute name="ruleId" type="xs:ID" use="optional"/>
	  <xs:attribute name="confidence" type="xs:decimal"	use="optional"/>
	</xs:complexType>
  </xs:element>

  <xs:element name="matchTypeFilter">
	<xs:complexType>
	  <xs:sequence>
		<xs:element ref="feature" minOccurs="0"	maxOccurs="unbounded"/>
	  </xs:sequence>
	</xs:complexType>
  </xs:element>

  <xs:element name="ruleExceptions">
	<xs:complexType>
	  <xs:sequence>
	    <xs:element ref="exception" minOccurs="0" maxOccurs="unbounded"/>
	  </xs:sequence>
	</xs:complexType>
  </xs:element>

  <xs:element name="exception">
	<xs:complexType>
	  <xs:simpleContent>
		<xs:extension base="xs:string">
		  <xs:attribute name="matchType" type="xs:string" use="required"/>
		</xs:extension>
	  </xs:simpleContent>
	</xs:complexType>
  </xs:element>

  <xs:element name="feature">
	<xs:complexType>
	  <xs:simpleContent>
		<xs:extension base="xs:string">
		  <xs:attribute name="name" type="xs:string" use="required"/>
		</xs:extension>
	  </xs:simpleContent>
	</xs:complexType>
  </xs:element>

  <xs:element name="annotation">
	<xs:complexType>
	  <xs:sequence>
		<xs:element ref="begin" minOccurs="1" maxOccurs="1"/>
		<xs:element ref="end" minOccurs="1" maxOccurs="1"/>
		<xs:element ref="setFeature" minOccurs="0" maxOccurs="unbounded"/>
	  </xs:sequence>
	  <xs:attribute name="id" type="xs:ID" use="required"/>
	  <xs:attribute name="type" type="xs:string" use="required"/>
	</xs:complexType>
  </xs:element>

  <xs:element name="updateMatchTypeAnnotation">
	<xs:complexType>
	  <xs:sequence>
	    <xs:element ref="setFeature" minOccurs="0" maxOccurs="unbounded"/>
	  </xs:sequence>
	</xs:complexType>
  </xs:element>

  <xs:element name="begin">
	<xs:complexType>
	  <xs:attribute name="group" use="required">
	    <xs:simpleType>
		  <xs:restriction base="xs:integer">
		    <xs:minInclusive value="0"/>
			<xs:maxInclusive value="9"/>
		  </xs:restriction>
		</xs:simpleType>
	  </xs:attribute>
	  <xs:attribute name="location" use="optional" default="start">
	    <xs:simpleType>
	      <xs:restriction base="xs:string">
		    <xs:enumeration value="start"/>
		    <xs:enumeration value="end"/>
		  </xs:restriction>
	    </xs:simpleType>
	  </xs:attribute>
	</xs:complexType>
  </xs:element>

  <xs:element name="end">
	<xs:complexType>
	  <xs:attribute name="group" use="required">
		<xs:simpleType>
		  <xs:restriction base="xs:integer">
			<xs:minInclusive value="0"/>
			<xs:maxInclusive value="9"/>
		  </xs:restriction>
		</xs:simpleType>
	  </xs:attribute>
	  <xs:attribute name="location" use="optional" default="end">
		<xs:simpleType>
		  <xs:restriction base="xs:string">
		    <xs:enumeration value="start"/>
			<xs:enumeration value="end"/>
		  </xs:restriction>
		</xs:simpleType>
	  </xs:attribute>
	</xs:complexType>
  </xs:element>

  <xs:element name="setFeature">
	<xs:complexType>
	  <xs:simpleContent>
		<xs:extension base="xs:string">
		  <xs:attribute name="name" type="xs:string" use="required"/>
		  <xs:attribute name="type" use="required">
		    <xs:simpleType>
			  <xs:restriction base="xs:string">
			    <xs:enumeration value="String"/>
				<xs:enumeration value="Integer"/>
				<xs:enumeration value="Float"/>
				<xs:enumeration value="Reference"/>
				<xs:enumeration value="Confidence"/>
				<xs:enumeration value="RuleId"/>
			  </xs:restriction>
			</xs:simpleType>
		  </xs:attribute>
		</xs:extension>
	  </xs:simpleContent>
	</xs:complexType>
  </xs:element>
</xs:schema>
]]></programlisting>
			  
			</para>

</appendix>

</book>